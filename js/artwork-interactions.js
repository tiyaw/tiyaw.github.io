// Artwork Interactions Manager
class ArtworkInteractionsManager {
  constructor() {
    // State
    this.currentImageIndex = 0;
    this.images = [];
    this.tooltip = null;
    this.modal = null;
    
    // Initialize
    this.init();
  }

  init() {
    // Get all artwork images
    this.images = Array.from(document.querySelectorAll('.masonry .column img'));
    
    // Create tooltip
    this.createTooltip();
    
    // Bind events (tooltip behavior only — modal related click behavior removed)
    this.bindEvents();
    
    // Add descriptions to images (temporary, should come from data attributes)
    this.addTemporaryDescriptions();
  }

  createTooltip() {
    this.tooltip = document.createElement('div');
    this.tooltip.className = 'tw-artwork-tooltip';
    document.body.appendChild(this.tooltip);
  }

  createModal() {
    // Modal removed per request — no-op placeholder kept for compatibility
    return;
  }

  bindEvents() {
    // Hover events for tooltip
    this.images.forEach(img => {
      img.addEventListener('mouseenter', e => this.showTooltip(e));
      img.addEventListener('mousemove', e => this.moveTooltip(e));
      img.addEventListener('mouseleave', () => this.hideTooltip());
    });
    
    // No modal-related event bindings (click, keyboard nav) — only tooltip behavior remains
  }

  showTooltip(e) {
    const description = e.target.dataset.description;
    if (!description) return;
    
    this.tooltip.textContent = description;
    this.tooltip.classList.add('visible');
    this.moveTooltip(e);
  }

  moveTooltip(e) {
    const padding = 15;
    const rect = this.tooltip.getBoundingClientRect();
    
    let x = e.clientX + padding;
    let y = e.clientY + padding;
    
    // Keep tooltip within viewport
    if (x + rect.width > window.innerWidth) {
      x = e.clientX - rect.width - padding;
    }
    if (y + rect.height > window.innerHeight) {
      y = e.clientY - rect.height - padding;
    }
    
    this.tooltip.style.left = x + 'px';
    this.tooltip.style.top = y + 'px';
  }

  hideTooltip() {
    this.tooltip.classList.remove('visible');
  }

  showModal(e) {
    // Modal behavior removed — clicking artworks no longer opens an overlay
    return;
  }

  hideModal() {
    // Modal removed — nothing to hide
    return;
  }

  showPrevImage() {
    // removed
    return;
  }

  showNextImage() {
    // removed
    return;
  }

  updateModalImage() {
    // removed
    return;
  }

  addTemporaryDescriptions() {
    // Modular description loader
    // Priority (highest -> lowest):
    // 1. explicit `data-description` attribute on the <img>
    // 2. mapping supplied in `window.ARTWORK_DESCRIPTIONS` (filename -> description)
    // 3. autogenerated label derived from the filename
    this.descriptionsMap = window.ARTWORK_DESCRIPTIONS || {};

    this.images.forEach((img) => {
      // if already provided in markup, keep it
      if (img.dataset.description && img.dataset.description.trim().length) return;

      // try map lookup by filename
      const src = img.getAttribute('src') || '';
      const filename = src.split('/').pop();
      if (filename && this.descriptionsMap[filename]) {
        img.dataset.description = this.descriptionsMap[filename];
        return;
      }

      // fallback: generate a sensible label from filename
      img.dataset.description = this.filenameToLabel(filename || src);
    });

    // Add visible labels under each image so artworks are labeled on the page
    this.addLabelsToDOM();
  }

  // Convert a filename like "Touchdesigner-1.gif" -> "Touchdesigner 1"
  filenameToLabel(filename) {
    if (!filename) return '';
    // remove querystring/hash
    filename = filename.split('?')[0].split('#')[0];
    // remove extension
    const noExt = filename.replace(/\.[^/.]+$/, '');
    // replace non-word characters with spaces, collapse spaces
    const words = noExt.replace(/[\W_]+/g, ' ').trim();
    if (!words) return noExt;
    // Capitalize first letter
    return words.replace(/\b\w/, c => c.toUpperCase());
  }

  addLabelsToDOM() {
    this.images.forEach(img => {
      // avoid duplicating labels
      if (img.nextElementSibling && img.nextElementSibling.classList && img.nextElementSibling.classList.contains('artwork-label')) {
        return;
      }

      const labelText = img.dataset.description || '';
      const label = document.createElement('div');
      label.className = 'artwork-label';
      label.textContent = labelText;

      // Minimal styling (prefer external CSS override). Uses CSS variable `--text-color` if present.
      label.style.fontSize = '0.9rem';
      label.style.marginTop = '0.4rem';
      label.style.lineHeight = '1.2';
      label.style.color = 'var(--text-color, rgba(0,0,0,0.75))';
      label.style.fontFamily = 'inherit';

      // Insert label after image
      img.parentNode.insertBefore(label, img.nextSibling);
    });
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new ArtworkInteractionsManager();
});